<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go 环境搭建</title>
      <link href="/post/a25657cf.html"/>
      <url>/post/a25657cf.html</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>首先去 <a href="https://golang.google.cn/dl/">Go官网</a> 下载go的安装包，根据自己的操作系统，选择相应的安装包下载</p><blockquote><p>说明：本文以 Windows 为例来安装 Go 环境</p></blockquote><p>下载完安装包后，双击安装包，傻瓜式安装即可，Windows 的 Go 默认安装路径为:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 代码解读复制代码macOS的<span class="keyword">go</span>默认安装路径：/usr/local/<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">Windows的<span class="keyword">go</span>默认安装路径：C:/<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>安装完成之后，配置 GO 环境变量。编辑.bash_profile文件，在该文件下增加以下内容（根据自己的实际情况进行配置）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash 代码解读复制代码1、打开.bash_profile文件</span><br><span class="line">vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line">2、在配置文件中增加以下内容（编辑完之后保存并退出）</span><br><span class="line"><span class="comment">#Seeting path for Golang（这一行是注释）</span></span><br><span class="line"><span class="built_in">export</span> GOROOT=/usr/local/go <span class="comment">#go的安装路径</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$GOROOT</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> GOPATH=/Users/shulv/studySpace/GolangProject <span class="comment">#我们的工作区。后边会详细介绍</span></span><br><span class="line"><span class="built_in">export</span> GOBIN=/Users/shulv/studySpace/GolangProject/bin#这里存放的是源代码编译后生成的可执行文件</span><br><span class="line"></span><br><span class="line">3、使刚才编辑的.bash_profile立刻生效。执行</span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><p>执行以下命令来验证是否安装成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、查看版本信息</span></span><br><span class="line">go version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、查看Go默认环境变量</span></span><br><span class="line">go <span class="built_in">env</span></span><br></pre></td></tr></table></figure><p>如果看到正确的打印结果，说明环境安装成功</p><h2 id="环境变量介绍"><a href="#环境变量介绍" class="headerlink" title="环境变量介绍"></a>环境变量介绍</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 代码解读复制代码<span class="number">1</span>、查看全部的<span class="keyword">go</span>环境变量</span><br><span class="line"><span class="keyword">go</span> env</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、查看指定的<span class="keyword">go</span>环境变量</span><br><span class="line"><span class="keyword">go</span> env 环境变量名称（如：<span class="keyword">go</span> env GOROOT 查看<span class="keyword">go</span>的安装目录）</span><br></pre></td></tr></table></figure><p>下边是我本机的go环境变量</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">ini 代码解读复制代码<span class="attr">GO111MODULE</span>=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">GOARCH</span>=<span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="attr">GOBIN</span>=<span class="string">&quot;/Users/shulv/studySpace/GolangProject/bin&quot;</span></span><br><span class="line"><span class="attr">GOCACHE</span>=<span class="string">&quot;/Users/shulv/Library/Caches/go-build&quot;</span></span><br><span class="line"><span class="attr">GOENV</span>=<span class="string">&quot;/Users/shulv/Library/Application Support/go/env&quot;</span></span><br><span class="line"><span class="attr">GOEXE</span>=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">GOFLAGS</span>=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">GOHOSTARCH</span>=<span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="attr">GOHOSTOS</span>=<span class="string">&quot;darwin&quot;</span></span><br><span class="line"><span class="attr">GOINSECURE</span>=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">GOMODCACHE</span>=<span class="string">&quot;/Users/shulv/studySpace/GolangProject/pkg/mod&quot;</span></span><br><span class="line"><span class="attr">GONOPROXY</span>=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">GONOSUMDB</span>=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">GOOS</span>=<span class="string">&quot;darwin&quot;</span></span><br><span class="line"><span class="attr">GOPATH</span>=<span class="string">&quot;/Users/shulv/studySpace/GolangProject&quot;</span></span><br><span class="line"><span class="attr">GOPRIVATE</span>=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">GOPROXY</span>=<span class="string">&quot;&lt;https://proxy.golang.org&gt;,direct&quot;</span></span><br><span class="line"><span class="attr">GOROOT</span>=<span class="string">&quot;/usr/local/go&quot;</span></span><br><span class="line"><span class="attr">GOSUMDB</span>=<span class="string">&quot;sum.golang.org&quot;</span></span><br><span class="line"><span class="attr">GOTMPDIR</span>=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">GOTOOLDIR</span>=<span class="string">&quot;/usr/local/go/pkg/tool/darwin_amd64&quot;</span></span><br><span class="line"><span class="attr">GOVCS</span>=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">GOVERSION</span>=<span class="string">&quot;go1.16.6&quot;</span></span><br><span class="line"><span class="attr">GCCGO</span>=<span class="string">&quot;gccgo&quot;</span></span><br><span class="line"><span class="attr">AR</span>=<span class="string">&quot;ar&quot;</span></span><br><span class="line"><span class="attr">CC</span>=<span class="string">&quot;clang&quot;</span></span><br><span class="line"><span class="attr">CXX</span>=<span class="string">&quot;clang++&quot;</span></span><br><span class="line"><span class="attr">CGO_ENABLED</span>=<span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="attr">GOMOD</span>=<span class="string">&quot;/dev/null&quot;</span></span><br><span class="line"><span class="attr">CGO_CFLAGS</span>=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line"><span class="attr">CGO_CPPFLAGS</span>=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">CGO_CXXFLAGS</span>=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line"><span class="attr">CGO_FFLAGS</span>=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line"><span class="attr">CGO_LDFLAGS</span>=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line"><span class="attr">PKG_CONFIG</span>=<span class="string">&quot;pkg-config&quot;</span></span><br><span class="line"><span class="attr">GOGCCFLAGS</span>=<span class="string">&quot;-fPIC -arch x86_64 -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/v2/8n4xnrln7l34q18v_2dt6tdr0000gn/T/go-build1451458835=/tmp/go-build -gno-record-gcc-switches -fno-common&quot;</span></span><br></pre></td></tr></table></figure><p>go中可设置的环境变量虽然有很多，但是很多我们可能都用不到，了解以下几个就差不多了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 代码解读复制代码GOROOT</span><br><span class="line">GOPATH</span><br><span class="line">GOBIN</span><br><span class="line">GOOS</span><br><span class="line">GOARCH</span><br><span class="line">GOPROXY</span><br><span class="line">GO111MODULE</span><br></pre></td></tr></table></figure><h3 id="GOROOT"><a href="#GOROOT" class="headerlink" title="GOROOT"></a>GOROOT</h3><p><strong>GOROOT是go语言的安装目录，它的作用就是用来索引go安装目录下的资源</strong>，比如go安装目录下的bin目录中包含go提供的工具，如一些常用的go命令。上边在介绍go环境安装的时候，配置环境变量GOBIN的时候，该环境变量的值就是GOROOT&#x2F;bin，也就是GO安装目录下边的bin目录。并将该路径拼接到了GOROOT&#x2F;bin，也就是GO安装目录下边的bin目录。并将该路径拼接到了GOROOT&#x2F;bin，也就是GO安装目录下边的bin目录。并将该路径拼接到了PATH中，这样就可以全局使用go提供的一些命令</p><p>go安装目录下的目录结构（MacOS的go默认安装路径为：&#x2F;usr&#x2F;local&#x2F;go）</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">css 代码解读复制代码AUTHORS          官方 Go语言作者列表</span><br><span class="line">CONTRIBUTING<span class="selector-class">.md</span></span><br><span class="line">CONTRIBUTORS     第三方的贡献者</span><br><span class="line">LICENSE          Go语言发布授权协议</span><br><span class="line">PATENTS          专利</span><br><span class="line">README<span class="selector-class">.md</span></span><br><span class="line">SECURITY<span class="selector-class">.md</span></span><br><span class="line">VERSION</span><br><span class="line">api             存放Go API检查器的辅助文件</span><br><span class="line">bin             存放所有由官方提供的Go语言相关工具的可执行文件。默认情况下，该目录会包含go和gofmt这两个工具</span><br><span class="line">doc             存放Go语言几乎全部的<span class="selector-tag">HTML</span>格式的官方文档和说明，方便开发者在离线时查看</span><br><span class="line">favicon<span class="selector-class">.ico</span></span><br><span class="line">lib             文档模版</span><br><span class="line">misc            存放各类编辑器或IDE（集成开发环境）软件的插件，辅助它们查看和编写Go代码</span><br><span class="line">pkg             用于在构建安装后，保存Go语言标准库的所有归档文件。Go源码文件对应于以“<span class="selector-class">.a</span>”为结尾的归档文件，它们就存储在pkg文件夹下的平台相关目录中</span><br><span class="line">robots<span class="selector-class">.txt</span>      搜索引擎robots文件</span><br><span class="line"><span class="attribute">src</span>             存放所有标准库、Go语言工具，以及相关底层库（C语言实现）的源码</span><br><span class="line">test            存放测试Go语言自身代码的文件</span><br></pre></td></tr></table></figure><h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><blockquote><p>说明：GOPATH的值不能和GOROOT值相同</p></blockquote><p><strong>GOPATH设置的是我们的开发区，用来存放我们项目的源代码</strong>。在macOS或Linux操作系统中，GOPATH的默认路径是$HOME&#x2F;go</p><p>GOPATH可以设置多个值，也就是多个工作区，多个工作区之间用分号隔开</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">javascript</span><br><span class="line"></span><br><span class="line"> 代码解读</span><br><span class="line">复制代码<span class="variable constant_">GOPATH</span>=<span class="regexp">/Users/</span>shulv/studySpace/<span class="title class_">GolangProject</span>;<span class="regexp">/Users/</span>shulv/studySpace/<span class="title class_">GolangProject1</span></span><br></pre></td></tr></table></figure><p><strong>如果GOPATH设置了两个工作区，当我们执行go get命令去获取远程库的时候，它会选择最前边那个工作区进行安装</strong></p><p>按照go语言的开发规范，工作区目录下一般分三个子目录：<strong>src, pkg, bin</strong></p><p>bin：存放编译后的可执行文件；</p><p>pkg：存放编译后的包文件；</p><p>src：存放项目源文件</p><p>通常bin 和 pkg 目录可以不创建，go 命令会自动创建（如 go install），只需要创建手动去创建src目录即可</p><h3 id="GOBIN"><a href="#GOBIN" class="headerlink" title="GOBIN"></a>GOBIN</h3><p><strong>GOBIN用来存放我们的项目代码编译后生成的二进制文件</strong> （可执行文件）。当我们使用go install命令编译打包我们的项目代码时，它会将编译后生成的二进制文件放入到GOBIN指定的目录下。<strong>如果没有指定GOBIN目录，默认是GOPATH&#x2F;bin</strong></p><h3 id="GOOS"><a href="#GOOS" class="headerlink" title="GOOS"></a>GOOS</h3><p><strong>GOOS的值是为其编译代码的操作系统</strong>。例如：linux、darwin、windows、netbsd、freebsd、openbsd、solaris</p><p>macOS操作系统对应的值是darwin。可以通过执行go env GOOS查看</p><h3 id="GOARCH"><a href="#GOARCH" class="headerlink" title="GOARCH"></a>GOARCH</h3><p><strong>GOARCH的值是为其编译代码的CPU架构或处理器</strong>。比如amd64、386、arm等</p><p>GOARCH和GOOS是成对出现的，比如，如果是macOS系统，那么它们就有以下几种组合形式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 代码解读复制代码GOOS        GOARCH</span><br><span class="line">darwin    386</span><br><span class="line">darwin    amd64</span><br><span class="line">darwin    arm</span><br><span class="line">darwin    arm64</span><br></pre></td></tr></table></figure><blockquote><p>GOOS和GOARCH这两个环境变量有什么作用呢？</p></blockquote><p>如果我们想在一个平台上可以生成在另一个平台上运行的程序，就需要借助这两个环境变量。对于其它的编程语言，如果想实现在一个平台上可以生成在另一个平台上运行的程序，比如在32位的windows操作系统环境中，生成可以在64位Linux操作系统上运行的二进制程序，通常需要借助第三方的工具才能够实现。但是在GO语言中，只需要设置GOOS和GOARCH这两个环境变量就可以实现</p><p>比如我现在在32为的windows操作系统中，想编译能在64为的Linux系统运行的目标程序</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 代码解读复制代码<span class="number">1</span>、设置GOOS和GOARCH分别为</span><br><span class="line">linux    amd64</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、编译目标源代码</span><br><span class="line"><span class="keyword">go</span> build test.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><h3 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h3><p><strong>GOPROXY设置的是，go get 下载依赖时使用的代理地址列表</strong>。该环境变量也可以设置多个值，多个值之间使用逗号 或竖杠分隔。GOPROXY的默认值为：<a href="https://proxy.golang.org/">proxy.golang.org</a>,direct</p><p>当用 go 命令查找依赖模块时，它会按顺序访问 GOPROXY 列表中的每个代理，直到收到成功的响应或出现终端错误</p><p>GOPROXY 中可能会存在两个关键字来代替代理URL</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">makefile 代码解读复制代码off:不允许从任何源下载依赖的模块</span><br><span class="line"><span class="section">direct: 直接从版本控制存储库下载，而不是使用模块代理</span></span><br></pre></td></tr></table></figure><h3 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h3><blockquote><p>说明：如果你是go语言入门的小白，不知道什么是代码包、命令源码文件、等等，建议先不看这部分，直接看最后的结果，解决安装好go之后，无法编译运行引入其它依赖包的命令源码文件问题</p></blockquote><p>GO111MODULE是 go modules 功能的开关，<strong>go modules 是 Go 语言的依赖解决方案</strong>，发布于 Go1.11，到Go1.14 推荐在生产上使用。下边简单介绍一下为什么会出现这个 go modules ，更详细的内容，会在后边的文章中系统梳理</p><p>为了方便理解下边的内容，首先需要知道，当我们编译一个依赖了其它包的go源码文件时，go查找依赖包的过程是什么样的？这个关乎到go的版本，以及GO111MODULE环境变量的配置。我的安装的go版本及GO111MODULE配置如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 代码解读复制代码<span class="keyword">go</span>版本（<span class="keyword">go</span> version命令查看）</span><br><span class="line"><span class="keyword">go</span> version go1<span class="number">.16</span><span class="number">.6</span> darwin/amd64</span><br><span class="line"></span><br><span class="line">GO111MODULE配置的值（<span class="keyword">go</span> env GO111MODULE命令查看）</span><br><span class="line">GO111MODULE=<span class="string">&quot;&quot;</span>（我没有设置这个值，它默认是空字符串）</span><br></pre></td></tr></table></figure><p>先看一下我的项目目录结构，以及文件内容</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 代码解读复制代码我的GOPATH对应目录的结构</span><br><span class="line">├── bin</span><br><span class="line">├── pkg</span><br><span class="line">└── src</span><br><span class="line">    ├── entry</span><br><span class="line">    │   └── study.<span class="keyword">go</span></span><br><span class="line">    └── studygo</span><br><span class="line">        └── learnGo.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">study.<span class="keyword">go</span>内容</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;studygo&quot;</span><span class="comment">//引入studygo这个包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">studygo.Test() <span class="comment">//使用studygo这个包下的Test()方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">learnGo.<span class="keyword">go</span>内容</span><br><span class="line"><span class="keyword">package</span> studygo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Just a test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我使用go run study.go去编译运行study.go这个源码文件，看一下会提示什么？</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 代码解读复制代码执行：<span class="keyword">go</span> run study.<span class="keyword">go</span> </span><br><span class="line"></span><br><span class="line">输出结果：study.<span class="keyword">go</span>:<span class="number">3</span>:<span class="number">8</span>: <span class="keyword">package</span> studygo is not in GOROOT (/usr/local/<span class="keyword">go</span>/src/studygo)</span><br></pre></td></tr></table></figure><p>提示说：studygo这个包，不在GOROOT这个路径下。也就是说，它在编译执行的过程中，会去GOROOT目录下找使用到的依赖包。关于它如何去找这个包，就跟我们环境变量<strong>GO111MODULE</strong>有关</p><p>下边就看看<strong>GO111MODULE</strong>设置不同的值，会有什么样的影响</p><blockquote><p>要想了解go modules到底解决了什么问题，先要了解我设置不同的值，会有什么样的效果</p></blockquote><ul><li><strong>GO111MODULE&#x3D;off，无模块支持</strong>。go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。意思就是，当我们编译执行一个go源码文件的时候，如果文件中有依赖其它包，它会首先去GOROOT指定的路径下查找，然后再去GOPATH指定的路径下查找</li><li><strong>GO111MODULE&#x3D;on，模块支持</strong>。go命令行会使用modules，而一点也不会去GOPATH目录下查找</li><li><strong>GO111MODULE&#x3D;auto，默认值</strong>。go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形： （1）当前目录在GOPATH&#x2F;src之外且该目录包含go.mod文件，开启模块支持。 （2）当前文件在包含go.mod文件的目录下面。</li></ul><p>我安装的go是1.16.6版本的，GO111MODULE默认是空，可以理解成上边说的auto，当该值为auto时，go在找相关依赖的时候，并不会去GOPATH中找，所以上边我们编译执行study.go的时候，会提示找不到依赖。解决办法就是将GO111MODULE设置成off，我们期望的是它在找依赖的时候，如果在GOROOT下没有找到的时候，会去GOPATH下边找</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">ini 代码解读复制代码设置GO111MODULE的值为off</span><br><span class="line">go env -w <span class="attr">GO111MODULE</span>=<span class="literal">off</span></span><br></pre></td></tr></table></figure><p>此时再编译执行study.go，就可以正常打印出结果了</p><blockquote><p>go modules解决了什么问题？</p></blockquote><ol><li>解决Go 语言长久以来的依赖管理问题</li><li>“淘汰”现有的 GOPATH 的使用模式</li><li>统一社区中的其它的依赖管理工具（提供迁移功能）</li></ol><p>为什么要淘汰GOPATH 的使用模式？GOPATH 使用模式的缺点是什么？如何用go mod管理一个新项目？这些会在下一篇文章中详细分享</p><p>以上仅仅是为了方便大家理解，为什么我们在安装完go以后，使用默认配置，在编译运行一个有依赖包的源码文件时，会报错的问题。关于go modules还有很多的内容，此处因为篇幅原因，不在这里详解，会在后边单独找一篇文章分享。以上内容，如果有理解不正确的地方，欢迎大家评论区指正</p><p>作者：书旅<br>链接：<a href="https://juejin.cn/post/6991361296914448391">https://juejin.cn/post/6991361296914448391</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 常用命令</title>
      <link href="/post/fb0e9651.html"/>
      <url>/post/fb0e9651.html</url>
      
        <content type="html"><![CDATA[<p>本文主要分享go语言中一些常用的命令，包括使用、命令底层执行过、区别等。预了解本部分内容，需要对go源码文件的分类及代码包有一定的了解，如果你也是新手，可以先移步<a href="https://juejin.cn/post/6991686092093128734">这里</a></p><h1 id="GO常用命令详解"><a href="#GO常用命令详解" class="headerlink" title="GO常用命令详解"></a>GO常用命令详解</h1><h2 id="查看go全部命令"><a href="#查看go全部命令" class="headerlink" title="查看go全部命令"></a>查看go全部命令</h2><p>可以通过以下命令来查看go的命令有哪些，以及每个命令的含义</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">arduino 代码解读复制代码执行：go help</span><br><span class="line"></span><br><span class="line">结果打印：</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">go &lt;command&gt; [arguments]</span><br><span class="line"></span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">bug         start a bug report  打开错误报告</span><br><span class="line">build       compile packages <span class="keyword">and</span> dependencies  <span class="comment">//编译包和依赖</span></span><br><span class="line">clean       remove object files <span class="keyword">and</span> cached files  <span class="comment">//删除目标文件和缓存文件</span></span><br><span class="line">doc         show documentation <span class="keyword">for</span> package <span class="keyword">or</span> symbol <span class="comment">//打印附于Go语言程序实体上的文档（在非 main 包下，执行 go doc 打印当前代码包文档及其程序实体列表（程序实体：变量、常量、函数、结构体以及接口））</span></span><br><span class="line">env         print Go environment information <span class="comment">//打印go环境变量信息</span></span><br><span class="line">fix         update packages to use <span class="keyword">new</span> APIs  <span class="comment">//更新包以使用新的API</span></span><br><span class="line">fmt         <span class="built_in">gofmt</span> (reformat) package sources <span class="comment">//格式化代码文件（Go语言的开发团队制定了统一的官方代码风格，并且推出了 gofmt 工具（gofmt 或 go fmt）来帮助开发者格式化他们的代码到统一的风格）</span></span><br><span class="line">generate    generate Go files by processing source <span class="comment">//go generate命令是在Go语言 1.4 版本里面新添加的一个命令，当运行该命令时，它将扫描与当前包相关的源代码文件，找出所有包含//go:generate的特殊注释，提取并执行该特殊注释后面的命令</span></span><br><span class="line">get         download <span class="keyword">and</span> install packages <span class="keyword">and</span> dependencies  <span class="comment">//下载并安装软件包和依赖项</span></span><br><span class="line">install     compile <span class="keyword">and</span> install packages <span class="keyword">and</span> dependencies <span class="comment">//编译和安装包和依赖项</span></span><br><span class="line">list        list packages <span class="keyword">or</span> modules  <span class="comment">//列出包或模块</span></span><br><span class="line">mod         <span class="keyword">module</span> maintenance <span class="comment">//模块管理</span></span><br><span class="line">run         compile <span class="keyword">and</span> run Go program  <span class="comment">//编译和运行一个go程序</span></span><br><span class="line">test        test packages <span class="comment">//测试包</span></span><br><span class="line">tool        run specified go tool <span class="comment">// 运行指定的 go 工具</span></span><br><span class="line">version     print Go version <span class="comment">//打印go的版本信息</span></span><br><span class="line">vet         report likely mistakes in packages <span class="comment">// 报告包中可能存在的错误</span></span><br></pre></td></tr></table></figure><h2 id="查看go指定命令的用法"><a href="#查看go指定命令的用法" class="headerlink" title="查看go指定命令的用法"></a>查看go指定命令的用法</h2><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">vbnet 代码解读复制代码方法：go help 命令名称（以env命令为例）</span><br><span class="line">执行：go help env</span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line"><span class="symbol">usage:</span> go env [-json] [-u] [-w] [var ...]</span><br><span class="line"></span><br><span class="line">Env prints Go environment information.</span><br><span class="line"></span><br><span class="line"><span class="keyword">By</span> <span class="keyword">default</span> env prints information <span class="keyword">as</span> a shell script</span><br><span class="line">(<span class="keyword">on</span> Windows, a batch file). <span class="keyword">If</span> one <span class="built_in">or</span> more variable</span><br><span class="line">names <span class="built_in">is</span> given <span class="keyword">as</span> arguments, env prints the value <span class="keyword">of</span></span><br><span class="line"><span class="keyword">each</span> named variable <span class="keyword">on</span> its own line.</span><br><span class="line"></span><br><span class="line">The -json flag prints the environment <span class="keyword">in</span> JSON format</span><br><span class="line">instead <span class="keyword">of</span> <span class="keyword">as</span> a shell script.</span><br><span class="line"></span><br><span class="line">The -u flag requires one <span class="built_in">or</span> more arguments <span class="built_in">and</span> unsets</span><br><span class="line">the <span class="keyword">default</span> setting <span class="keyword">for</span> the named environment variables,</span><br><span class="line"><span class="keyword">if</span> one has been <span class="keyword">set</span> <span class="keyword">with</span> <span class="comment">&#x27;go env -w&#x27;.</span></span><br><span class="line"></span><br><span class="line">The -w flag requires one <span class="built_in">or</span> more arguments <span class="keyword">of</span> the</span><br><span class="line">form NAME=VALUE <span class="built_in">and</span> changes the <span class="keyword">default</span> settings</span><br><span class="line"><span class="keyword">of</span> the named environment variables <span class="keyword">to</span> the given values.</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> more about environment variables, see <span class="comment">&#x27;go help environment&#x27;.</span></span><br></pre></td></tr></table></figure><h1 id="常用命令详解"><a href="#常用命令详解" class="headerlink" title="常用命令详解"></a>常用命令详解</h1><p>虽然go的命令有十几个，但是我们最常用到的并没有几个，下边下详细介绍：go build、go get、go install、go run，这四个最常用的命令</p><h2 id="四个常用命令的通用参数"><a href="#四个常用命令的通用参数" class="headerlink" title="四个常用命令的通用参数"></a>四个常用命令的通用参数</h2><ul><li><strong>-a</strong>：用于<strong>强制重新编译所有涉及的Go语言代码包</strong>（包括 Go 语言标准库中的代码包），<strong>即使它们已经是最新的了</strong>。该标记可以让我们有机会通过改动底层的代码包做一些实验。假设我有一个命令源码，它里边导入了代码包A，而这个代码包A，我之前编译过，并且编译之后，A这个源码包中的代码，没有产生任何的变化，go run命令在不加任何参数的默认情况下，是不会再次编译它的，但是加上-a参数之后，会再次它们，即使他们的归档文件已经存在，并且已经是最新的</li><li><strong>-n</strong>：<strong>仅打印其执行过程中用到的所有命令，而不去真正执行它们</strong>。如果只想查看或者验证命令的执行过程，而不想改变任何东西（不想产生任何后果），使用它正好合适</li><li><strong>-p n</strong>：该命令是go run特有的。<strong>并行编译，其中n为并行的数量</strong>。现在已经是多核时代，我们的计算机可能有多个CPU，或者我们的计算机有多个核，这个并行编译的标记，会使go run命令的编译操作更加迅速。<strong>这个n的值，最好设置成当前计算机的逻辑CPU个数</strong>。假设我们的计算机有两个CPU，每个CPU有两个核，那么这台计算机的逻辑CPU就是4</li><li><strong>-v</strong>：<strong>用于打印命令执行过程中涉及的代码包（列出被编译的代码包名称）</strong> 。包括我们指定的目标代码包，并且有时还会包括该代码包直接或间接依赖的那些代码包。这会让你知道哪些代码包被执行过了。<strong>注意：在go的1.3版本中，-v参数打印出来的代码包，包含go语言自带的标准库的代码包。但是，在go的1.4版本中，-v参数打印出来的代码包，不包含go语言自带的标准库的代码包（就算我们导入了go标准库的代码包，使用-v参数，也不会打印出来）</strong></li><li><strong>-work</strong>：<strong>用于打印命令执行时生成和使用的临时工作目录的名字，且命令执行完成后不删除它</strong>。这个目录下的文件可能会对你有用，也可以从侧面了解命令的执行过程。<strong>如果不添加此标记，那么临时工作目录会在命令执行完毕前删除</strong>。</li><li><strong>-x</strong>：打印编译过程中用到的所有命令，<strong>并同时执行它们</strong>。（而-n参数是不真正执行它们）</li><li><strong>-race</strong>：<strong>用于检测并报告指定 Go 语言程序中存在的数据竞争问题</strong>。当用 Go 语言编写并发程序的时候，这是很重要的检测手段之一</li></ul><p>下边在介绍go的具体命令时，会展示各个参数的使用及效果</p><h2 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h2><p>go run是专门用来运行<strong>命令源码文件</strong>的命令。并不是用来运行所有的go源码文件的</p><p>go run 命令只能接受一<strong>个命令源码文件</strong>以及<strong>若干个库源码文件</strong>（必须同属于 main 包）作为文件参数，且不能接受测试源码文件。这也就是说，go run命令后边可以跟多个源码文件，但其中只能有一个命令源码文件</p><h3 id="go-run命令内部的操作步骤"><a href="#go-run命令内部的操作步骤" class="headerlink" title="go run命令内部的操作步骤"></a>go run命令内部的操作步骤</h3><p>它会先编译作为文件参数的源码文件，将他们的编译结果，放到一个临时文件夹中，然后再去运行这个编译的结果，这个编译结果包括命令源码文件被编译后生成的<strong>可执行文件</strong> 以及 相关库源码文件编译后生成的<strong>归档文件</strong>（可能不太容易理解这段话，往下看示例）</p><p>下边通过代码示例来演示各个参数的作用及效果</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 代码解读复制代码在我的工作目录下有一个命令源码文件study.<span class="keyword">go</span>，内容如下</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Just a test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="n参数演示"><a href="#n参数演示" class="headerlink" title="-n参数演示"></a>-n参数演示</h3><p>使用-n参数来看编译执行一个命令源码文件过程中用到的命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash 代码解读复制代码执行：go run -n study.go</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$WORK</span>/b001/</span><br><span class="line"><span class="built_in">cat</span> &gt;<span class="variable">$WORK</span>/b001/importcfg &lt;&lt; <span class="string">&#x27;EOF&#x27;</span> <span class="comment"># internal</span></span><br><span class="line"><span class="comment"># import config</span></span><br><span class="line">packagefile <span class="built_in">fmt</span>=/usr/local/go/pkg/darwin_amd64/fmt.a</span><br><span class="line">packagefile runtime=/usr/local/go/pkg/darwin_amd64/runtime.a</span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">cd</span> /Users/shulv/studySpace/GolangProject/src/entry</span><br><span class="line">/usr/local/go/pkg/tool/darwin_amd64/compile -o <span class="variable">$WORK</span>/b001/_pkg_.a -trimpath <span class="string">&quot;<span class="variable">$WORK</span>/b001=&gt;&quot;</span> -p main -complete -buildid OZxgjhaidDSIEHCDtqvJ/OZxgjhaidDSIEHCDtqvJ -dwarf=<span class="literal">false</span> -goversion go1.16.6 -D _/Users/shulv/studySpace/GolangProject/src/entry -importcfg <span class="variable">$WORK</span>/b001/importcfg -pack -c=4 ./study.go</span><br><span class="line">/usr/local/go/pkg/tool/darwin_amd64/buildid -w <span class="variable">$WORK</span>/b001/_pkg_.a <span class="comment"># internal</span></span><br><span class="line"><span class="built_in">cat</span> &gt;<span class="variable">$WORK</span>/b001/importcfg.link &lt;&lt; <span class="string">&#x27;EOF&#x27;</span> <span class="comment"># internal</span></span><br><span class="line">packagefile command-line-arguments=<span class="variable">$WORK</span>/b001/_pkg_.a</span><br><span class="line">packagefile <span class="built_in">fmt</span>=/usr/local/go/pkg/darwin_amd64/fmt.a</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">packagefile internal/race=/usr/local/go/pkg/darwin_amd64/internal/race.a</span><br><span class="line">packagefile path=/usr/local/go/pkg/darwin_amd64/path.a</span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$WORK</span>/b001/exe/</span><br><span class="line"><span class="built_in">cd</span> .</span><br><span class="line">/usr/local/go/pkg/tool/darwin_amd64/link -o <span class="variable">$WORK</span>/b001/exe/study -importcfg <span class="variable">$WORK</span>/b001/importcfg.link -s -w -buildmode=exe -buildid=445UgZBfJLTSQgITptfl/OZxgjhaidDSIEHCDtqvJ/OZxgjhaidDSIEHCDtqvJ/445UgZBfJLTSQgITptfl -extld=clang <span class="variable">$WORK</span>/b001/_pkg_.a</span><br><span class="line"><span class="variable">$WORK</span>/b001/exe/study</span><br></pre></td></tr></table></figure><p>执行结果看起来好像很乱，但实际上，它做了以下几件事</p><ol><li><strong>创建一个临时目录b001</strong>：mkdir -p WORK&#x2F;b001&#x2F;（这个WORK&#x2F;b001&#x2F;（这个WORK&#x2F;b001&#x2F;（这个WORK不知道对应的是哪个路径没关系，别忘了我们还有-work参数，可以打印生成的临时工作目录）</li><li><strong>查找依赖信息</strong>：cat &gt;$WORK&#x2F;b001&#x2F;importcfg &lt;&lt; …</li><li><strong>执行源代码编译</strong>：&#x2F;usr&#x2F;local&#x2F;go&#x2F;pkg&#x2F;tool&#x2F;darwin_amd64&#x2F;compile -o …</li><li><strong>收集链接库文件</strong>：cat &gt;$WORK&#x2F;b001&#x2F;importcfg.link &lt;&lt; …</li><li><strong>在b001中创建临时目录exe</strong>：mkdir -p $WORK&#x2F;b001&#x2F;exe&#x2F;</li><li><strong>生成可执行文件</strong>：&#x2F;usr&#x2F;local&#x2F;go&#x2F;pkg&#x2F;tool&#x2F;darwin_amd64&#x2F;link -o …</li><li><strong>运行可执行文件</strong></li></ol><p>从结果中可以看出来，-n参数只打印了过程中所使用到的命令，并没有真正的执行，因为最后在执行可执行文件的时候，并没有将”Just a test“给打印出来</p><h3 id="work参数演示"><a href="#work参数演示" class="headerlink" title="-work参数演示"></a>-work参数演示</h3><p>使用-work参数，打印出执行过程中生成的临时工作目录</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 代码解读复制代码执行：<span class="keyword">go</span> run -work study.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">WORK=/<span class="keyword">var</span>/folders/v2/<span class="number">8</span>n4xnrln7l34q18v_2dt6tdr0000gn/T/<span class="keyword">go</span>-build1801219739</span><br><span class="line">Just a test</span><br></pre></td></tr></table></figure><p>可以看到结果中展示了临时目录的路径 和 源码文件的执行结果。因为使用-work参数之后，临时目录不会被删除，所以我们可以到这个临时目录中看其结构</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash 代码解读复制代码临时目录路径：/var/folders/v2/8n4xnrln7l34q18v_2dt6tdr0000gn/T/go-build1801219739</span><br><span class="line">目录结构：</span><br><span class="line">.</span><br><span class="line">└── b001</span><br><span class="line">    ├── _pkg_.a</span><br><span class="line">    ├── exe</span><br><span class="line">    │   └── study</span><br><span class="line">    ├── importcfg</span><br><span class="line">    └── importcfg.link</span><br></pre></td></tr></table></figure><h3 id="a参数演示"><a href="#a参数演示" class="headerlink" title="-a参数演示"></a>-a参数演示</h3><p><strong>-a</strong>参数用于<strong>强制重新编译所有涉及的Go语言代码包</strong>（包括 Go 语言标准库中的代码包），<strong>即使它们已经是最新的了</strong></p><p>上边我们已经对study.go文件编译执行过一次了，并且没有对文件内容进行修改。如果我们不使用-a参数，而是直接执行go run，它将不会再次执行编译过程，而是直接链接后执行。下边借助-n参数来证明一下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash 代码解读复制代码在源码文件没有被修改的情况下，再次执行：go run -n study.go</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">go run -n study.go </span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$WORK</span>/b001/</span><br><span class="line"><span class="built_in">cat</span> &gt;<span class="variable">$WORK</span>/b001/importcfg.link &lt;&lt; <span class="string">&#x27;EOF&#x27;</span> <span class="comment"># internal</span></span><br><span class="line">packagefile command-line-arguments=/Users/shulv/Library/Caches/go-build/d9/d98055ba422899604fd059aa39fc27972585449930cdd8fc3858b6149a749b27-d</span><br><span class="line">packagefile <span class="built_in">fmt</span>=/usr/local/go/pkg/darwin_amd64/fmt.a</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">packagefile internal/race=/usr/local/go/pkg/darwin_amd64/internal/race.a</span><br><span class="line">packagefile path=/usr/local/go/pkg/darwin_amd64/path.a</span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$WORK</span>/b001/exe/</span><br><span class="line"><span class="built_in">cd</span> .</span><br><span class="line">/usr/local/go/pkg/tool/darwin_amd64/link -o <span class="variable">$WORK</span>/b001/exe/study -importcfg <span class="variable">$WORK</span>/b001/importcfg.link -s -w -buildmode=exe -buildid=A5ZhwB9IgatL5rEMAAB6/OZxgjhaidDSIEHCDtqvJ/jKFA8Xft5BKXCFiDMFrC/A5ZhwB9IgatL5rEMAAB6 -extld=clang /Users/shulv/Library/Caches/go-build/d9/d98055ba422899604fd059aa39fc27972585449930cdd8fc3858b6149a749b27-d</span><br><span class="line"><span class="variable">$WORK</span>/b001/exe/study</span><br></pre></td></tr></table></figure><p>因为不加-work参数，在每次编译执行的后，会将临时目录删除，所以我们每次在执行go run的时候，它都会先创建临时目录，所以我们看到了：mkdir -p $WORK&#x2F;b001&#x2F;。然后我们看到查找完依赖之后，它接着创建了临时目录exe，后边就直接执行了link操作，最后执行了可执行文件。中间没有了编译操作</p><p>此时你可以在保证源文件没有修改的情况下，加上-a参数，会发现此时源文件被强制编译了，哪怕源文件没有修改（我这里就不再贴执行结果了）</p><h3 id="x参数演示"><a href="#x参数演示" class="headerlink" title="-x参数演示"></a>-x参数演示</h3><p>-x打印编译过程中用到的所有命令，并执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash 代码解读复制代码执行：go run -x study.go</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line">WORK=/var/folders/v2/8n4xnrln7l34q18v_2dt6tdr0000gn/T/go-build168647433</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$WORK</span>/b001/</span><br><span class="line"><span class="built_in">cat</span> &gt;<span class="variable">$WORK</span>/b001/importcfg.link &lt;&lt; <span class="string">&#x27;EOF&#x27;</span> <span class="comment"># internal</span></span><br><span class="line">packagefile command-line-arguments=/Users/shulv/Library/Caches/go-build/0a/0a84b98e4a2edf7cf6661ae1c30d9abe59977dff84f8a95dc3527499292fd168-d</span><br><span class="line">packagefile studygo=/Users/shulv/Library/Caches/go-build/b8/b826e18cb44b50e651c70cd14a931a1ed5e8e7669f7340c31b947ac8043787c4-d</span><br><span class="line">packagefile runtime=/usr/local/go/pkg/darwin_amd64/runtime.a</span><br><span class="line">......</span><br><span class="line">packagefile internal/race=/usr/local/go/pkg/darwin_amd64/internal/race.a</span><br><span class="line">packagefile path=/usr/local/go/pkg/darwin_amd64/path.a</span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$WORK</span>/b001/exe/</span><br><span class="line"><span class="built_in">cd</span> .</span><br><span class="line">/usr/local/go/pkg/tool/darwin_amd64/link -o <span class="variable">$WORK</span>/b001/exe/study -importcfg <span class="variable">$WORK</span>/b001/importcfg.link -s -w -buildmode=exe -buildid=POnNYYqFpCxtCoPh1xl9/_rKHpBsVyWow7NdS85MK/3k-oIa2YhBkHW0aWVSoW/POnNYYqFpCxtCoPh1xl9 -extld=clang /Users/shulv/Library/Caches/go-build/0a/0a84b98e4a2edf7cf6661ae1c30d9abe59977dff84f8a95dc3527499292fd168-d</span><br><span class="line"><span class="variable">$WORK</span>/b001/exe/study</span><br><span class="line">Just a <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>可以看到输出了整个编译运行过程中执行过的命令，并打印出了命令源码文件的执行结果</p><p>综上：go run的执行过程就是：源码 &#x3D;&#x3D;》编译 &#x3D;&#x3D;》连接 &#x3D;&#x3D;》可执行文件&#x3D;&#x3D;》执行输出</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b614c4ba532548dc9223ecd44bf213fd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><h6 id="图片来源：初探-Go-的编译命令执行过程"><a href="#图片来源：初探-Go-的编译命令执行过程" class="headerlink" title="图片来源：初探 Go 的编译命令执行过程"></a>图片来源：<a href="https://juejin.cn/post/6844903489986887687#heading-10">初探 Go 的编译命令执行过程</a></h6><h2 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h2><p><strong>go build 用于编译我们指定的源码文件或代码包以及它们的依赖包</strong>。<strong>go build完成了源码的编译与可执行文件的生成。go build接收参数为.go文件或目录，默认情况下编译当前目录下所有.go文件</strong></p><h3 id="go-build命令用法"><a href="#go-build命令用法" class="headerlink" title="go build命令用法"></a>go build命令用法</h3><ul><li><strong>如果go build后边跟的是一个命令源码文件</strong>，会在当前目录下生成一个可执行文件。如果想在$GOPATH&#x2F;bin目录下生成相应的可执行文件，需要执行go install（后边会介绍这个命令）或者使用 go build -o 路径&#x2F;可执行文件名称（如果使用go install命令需要注意：<strong>如果 GOPATH 里面只有一个工作区，就会在当前工作区的 bin 目录下生成相应的可执行文件。如果 GOPATH 下有多个工作区，则是在 GOBIN 下生成对应的可执行文件</strong>）</li><li><strong>如果go build后边跟的是一个库源码文件</strong>，它只是检查库源码文件的有效性，只会做检查性的编译，而不会输出任何结果文件</li><li><strong>如果仅使用go build，后边不跟任何参数，或者后边跟代码包导入路径</strong>，那么代码包中所有的go文件都会被编译（<strong>但是，go build 会忽略目录下以”_”或者”.”开头的go文件</strong>）</li><li><strong>go build 既不能编译包含多个命令源码文件的代码包，也不能同时编译多个命令源码文件</strong>。因为如果把多个命令源码文件作为一个整体看待，那么每个文件中的main函数都属于重名函数，在编译时会抛出重复定义错误</li></ul><h3 id="go-build命令使用演示"><a href="#go-build命令使用演示" class="headerlink" title="go build命令使用演示"></a>go build命令使用演示</h3><ol><li>go build 命令源码文件</li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 代码解读复制代码目录结构 &amp; 文件内容  还是和上边的示例一样</span><br><span class="line">├── bin</span><br><span class="line">├── pkg</span><br><span class="line">└── src</span><br><span class="line">    ├── entry</span><br><span class="line">    │   └── study.<span class="keyword">go</span> <span class="comment">// 命令源码文件</span></span><br><span class="line">    └── studygo</span><br><span class="line">        └── learnGo.<span class="keyword">go</span> <span class="comment">// 库源码文件</span></span><br><span class="line"></span><br><span class="line">在entry目录下执行：<span class="keyword">go</span> build study.<span class="keyword">go</span></span><br><span class="line">执行完之后，终端上不会有任何输出，此时看一下目录结构</span><br><span class="line">├── bin</span><br><span class="line">├── pkg</span><br><span class="line">└── src</span><br><span class="line">    ├── entry</span><br><span class="line">    │   ├── study <span class="comment">//新生成的可执行文件</span></span><br><span class="line">    │   └── study.<span class="keyword">go</span></span><br><span class="line">    └── studygo</span><br><span class="line">        └── learnGo.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><ol><li>go build 库源码文件</li></ol><p>进入到studygo目录下执行：go build learnGo.go。不会生成任何文件，现在可能看不出什么，后边在介绍go build的执行过程时，就会明白，执行这个命令之后，发生了什么</p><ol><li>go build</li></ol><p>直接在一个代码包下执行go build，后边不跟任何参数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 代码解读复制代码先删除刚才生成的study可执行文件，然后进入到entry目录执行：<span class="keyword">go</span> build</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">├── bin</span><br><span class="line">├── pkg</span><br><span class="line">└── src</span><br><span class="line">    ├── entry</span><br><span class="line">    │   ├── entry <span class="comment">//新生成的可执行文件</span></span><br><span class="line">    │   └── study.<span class="keyword">go</span></span><br><span class="line">    └── studygo</span><br><span class="line">        └── learnGo.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>相信聪明的你已经发现，如果go build后跟命令源码文件时，生成的的可执行文件名和命令源码文件一样，如果单纯执行go build，生成的可执行文件和当前代码包的名称是一样的</p><blockquote><p>在上边提到的公共参数，在go build中也是适用的，含义相同</p></blockquote><h3 id="go-build命令执行过程"><a href="#go-build命令执行过程" class="headerlink" title="go build命令执行过程"></a>go build命令执行过程</h3><p>可以利用上边提到的-n参数，来查看go build 在执行过程中都做了些什么</p><p><strong>go build编译命令源码文件过程</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash 代码解读复制代码进入到entry目录下执行：go build -n study.go</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$WORK</span>/b001/</span><br><span class="line"><span class="built_in">cat</span> &gt;<span class="variable">$WORK</span>/b001/importcfg &lt;&lt; <span class="string">&#x27;EOF&#x27;</span> <span class="comment"># internal</span></span><br><span class="line"><span class="comment"># import config</span></span><br><span class="line">packagefile <span class="built_in">fmt</span>=/usr/local/go/pkg/darwin_amd64/fmt.a</span><br><span class="line">packagefile runtime=/usr/local/go/pkg/darwin_amd64/runtime.a</span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">cd</span> /Users/shulv/studySpace/GolangProject/src/entry</span><br><span class="line">/usr/local/go/pkg/tool/darwin_amd64/compile -o <span class="variable">$WORK</span>/b001/_pkg_.a -trimpath <span class="string">&quot;<span class="variable">$WORK</span>/b001=&gt;&quot;</span> -p main -complete -buildid aPJghGhqw4j27W2678s0/aPJghGhqw4j27W2678s0 -goversion go1.16.6 -D _/Users/shulv/studySpace/GolangProject/src/entry -importcfg <span class="variable">$WORK</span>/b001/importcfg -pack -c=4 ./study.go</span><br><span class="line">/usr/local/go/pkg/tool/darwin_amd64/buildid -w <span class="variable">$WORK</span>/b001/_pkg_.a <span class="comment"># internal</span></span><br><span class="line"><span class="built_in">cat</span> &gt;<span class="variable">$WORK</span>/b001/importcfg.link &lt;&lt; <span class="string">&#x27;EOF&#x27;</span> <span class="comment"># internal</span></span><br><span class="line">packagefile command-line-arguments=<span class="variable">$WORK</span>/b001/_pkg_.a</span><br><span class="line">......</span><br><span class="line">packagefile internal/race=/usr/local/go/pkg/darwin_amd64/internal/race.a</span><br><span class="line">packagefile path=/usr/local/go/pkg/darwin_amd64/path.a</span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$WORK</span>/b001/exe/</span><br><span class="line"><span class="built_in">cd</span> .</span><br><span class="line">/usr/local/go/pkg/tool/darwin_amd64/link -o <span class="variable">$WORK</span>/b001/exe/a.out -importcfg <span class="variable">$WORK</span>/b001/importcfg.link -buildmode=exe -buildid=ZnGlctoVozInY7SAxZMW/aPJghGhqw4j27W2678s0/aPJghGhqw4j27W2678s0/ZnGlctoVozInY7SAxZMW -extld=clang <span class="variable">$WORK</span>/b001/_pkg_.a</span><br><span class="line">/usr/local/go/pkg/tool/darwin_amd64/buildid -w <span class="variable">$WORK</span>/b001/exe/a.out <span class="comment"># internal</span></span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$WORK</span>/b001/exe/a.out study</span><br></pre></td></tr></table></figure><p>可以发现，跟go run命令的执行过程几乎一样，不一样的地方就是在最下边一行。<strong>go run执行了生成的可执行文件，而go build 命令是把可执行文件移动到了当前目录的文件夹中</strong></p><p>我们可以通过-work参数来获取到生成的临时目录路径，然后看一下和go run生成的有何不同</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 代码解读复制代码这里展示一下我执行<span class="keyword">go</span> build -work study.<span class="keyword">go</span>，生成的临时目录结构</span><br><span class="line">.</span><br><span class="line">└── b001</span><br><span class="line">    ├── _pkg_.a</span><br><span class="line">    ├── exe</span><br><span class="line">    ├── importcfg</span><br><span class="line">    └── importcfg.link</span><br><span class="line"></span><br><span class="line">会发现，和<span class="keyword">go</span> run执行之后相比，exe目录下没了可执行文件。原因就是<span class="keyword">go</span> build执行之后，将可执行文件移到当前目录下了</span><br></pre></td></tr></table></figure><blockquote><p>可以发现，go build编译命令源码文件的过程就是：<strong>命令源码文件 &#x3D;&#x3D;》 编译 &#x3D;&#x3D;》链接 &#x3D;&#x3D;》可执行文件</strong></p></blockquote><p><strong>go build编译库源码文件过程</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash 代码解读复制代码进入studygo目录，执行：go build -n learnGo.go</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$WORK</span>/b001/</span><br><span class="line"><span class="built_in">cat</span> &gt;<span class="variable">$WORK</span>/b001/importcfg &lt;&lt; <span class="string">&#x27;EOF&#x27;</span> <span class="comment"># internal</span></span><br><span class="line"><span class="comment"># import config</span></span><br><span class="line">packagefile <span class="built_in">fmt</span>=/usr/local/go/pkg/darwin_amd64/fmt.a</span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">cd</span> /Users/shulv/studySpace/GolangProject/src/studygo</span><br><span class="line">/usr/local/go/pkg/tool/darwin_amd64/compile -o <span class="variable">$WORK</span>/b001/_pkg_.a -trimpath <span class="string">&quot;<span class="variable">$WORK</span>/b001=&gt;&quot;</span> -p command-line-arguments -complete -buildid WkKm9j3sTnSZXyJlO623/WkKm9j3sTnSZXyJlO623 -goversion go1.16.6 -D _/Users/shulv/studySpace/GolangProject/src/studygo -importcfg <span class="variable">$WORK</span>/b001/importcfg -pack -c=4 ./learnGo.go</span><br><span class="line">/usr/local/go/pkg/tool/darwin_amd64/buildid -w <span class="variable">$WORK</span>/b001/_pkg_.a <span class="comment"># internal</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到 go build 命令只是把库源码文件编译了一遍，其他什么事情都没有干。所以go build编译库源码文件的过程是：<strong>库源码文件 &#x3D;&#x3D;》 编译</strong> 。很明显，此时go build的作用就是测试库源码文件能否正常编译，用来测试编译</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8676c99bd9a4d9e819a42432f905cf1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><h6 id="图片来源：初探-Go-的编译命令执行过程-1"><a href="#图片来源：初探-Go-的编译命令执行过程-1" class="headerlink" title="图片来源：初探 Go 的编译命令执行过程"></a>图片来源：<a href="https://juejin.cn/post/6844903489986887687#heading-10">初探 Go 的编译命令执行过程</a></h6><h2 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h2><p><strong>go install 命令是用来编译并安装代码包或者源码文件的</strong></p><h3 id="go-install命令用法"><a href="#go-install命令用法" class="headerlink" title="go install命令用法"></a>go install命令用法</h3><p>当指定的代码包的依赖包还没有被编译和安装时，该命令会先去处理依赖包。与 go build 命令一样，传给 go install 命令的代码包参数应该以导入路径的形式提供。并且，go build 命令的绝大多数标记也都可以用于 go install 命令。实际上，go install 命令只比 go build 命令多做了一件事，即：<strong>安装编译后的结果文件到指定目录</strong></p><ul><li>安装代码包会在当前工作区的 pkg 的平台相关目录下生成归档文件（即 .a 文件）</li><li>安装命令源码文件会在当前工作区的 bin 目录（<strong>如果 GOPATH 下有多个工作区，就会放在 GOBIN 目录下</strong>）生成可执行文件</li><li>go install 命令如果后面不追加任何参数，它会把当前目录作为代码包并安装。这和 go build 命令是完全一样的</li><li>go install 命令后面如果跟了代码包导入路径作为参数，那么该代码包及其依赖都会被安装</li><li>go install 命令后面如果跟了命令源码文件以及相关库源码文件作为参数的话，只有这些被指定的文件会被编译并安装</li></ul><h3 id="go-install命令使用演示"><a href="#go-install命令使用演示" class="headerlink" title="go install命令使用演示"></a>go install命令使用演示</h3><p><strong>go install 命令源码文件</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 代码解读复制代码执行：<span class="keyword">go</span> install study.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">执行完之后，看目录结构变化</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── study <span class="comment">//新生成的可执行文件</span></span><br><span class="line">├── pkg</span><br><span class="line">└── src</span><br><span class="line">    ├── entry</span><br><span class="line">    │   └── study.<span class="keyword">go</span></span><br><span class="line">    └── studygo</span><br><span class="line">        └── learnGo.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p><strong>go install 库源码文件</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 代码解读复制代码执行：<span class="keyword">go</span> install</span><br><span class="line"></span><br><span class="line">执行完之后，看目录结构变化：</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── study</span><br><span class="line">├── pkg</span><br><span class="line">│   └── darwin_amd64</span><br><span class="line">│       └── studygo.a <span class="comment">//新生成的归档文件</span></span><br><span class="line">└── src</span><br><span class="line">    ├── entry</span><br><span class="line">    │   └── study.<span class="keyword">go</span></span><br><span class="line">    └── studygo</span><br><span class="line">        └── learnGo.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><h3 id="go-install命令执行过程"><a href="#go-install命令执行过程" class="headerlink" title="go install命令执行过程"></a>go install命令执行过程</h3><p>这里不再逐一展示go install编译安装命令源码文件和库源码文件的过程了，大家可以自己动手试试。我这里直接给出结论</p><ul><li>go install编译安装命令源码文件的过程和go build相比，多了最后一步，go install 会把编译命令源码文件生成的可执行文件安装到当前工作区的 bin 目录（如果 GOPATH 下有多个工作区，就会放在 GOBIN 目录下）</li><li>go install编译安装库源码文件的过程和go build相比，go install 会把编译库源码文件生成的归档文件安装到当前工作区的 pkg 目录</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6d069971cae412db72404bf36713275~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><h6 id="图片来源：初探-Go-的编译命令执行过程-2"><a href="#图片来源：初探-Go-的编译命令执行过程-2" class="headerlink" title="图片来源：初探 Go 的编译命令执行过程"></a>图片来源：<a href="https://juejin.cn/post/6844903489986887687#heading-10">初探 Go 的编译命令执行过程</a></h6><h2 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h2><p>go get 命令会自动从主流公用代码仓库下载代码包（比如github），它会<strong>把当前的代码包下载到 $GOPATH 中的第一个工作区的 src 目录中，并安装</strong></p><p>go get支持的代码版本控制系统有：Git、SVN、Mercurial(hg)、Bazaar</p><h3 id="go-get-命令常用参数"><a href="#go-get-命令常用参数" class="headerlink" title="go get 命令常用参数"></a>go get 命令常用参数</h3><ul><li><strong>-d</strong>：<strong>让命令程序只执行下载动作，而不执行安装动作</strong>。有些非常特殊的代码包在安装过程中需要有特殊的处理，我们需要先下载下来，暂时不进行安装动作，此时就可以用-d参数</li><li><strong>-u</strong>：<strong>加该参数可利用网络来更新已有代码包及其依赖包</strong>。<strong>默认情况下，该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包</strong>。如果已经下载过一个代码包，但是这个代码包又有更新了，那么这时候可以直接用-u参数来更新本地的对应的代码包。如果不加这个-u参数，执行 go get 命令获取一个已有的代码包，会发现命令什么都不执行。只有加了-u参数，命令才会去执行 git pull 命令拉取最新的代码包的最新版本，下载并安装</li><li><strong>-f</strong>：<strong>仅在使用-u标记时才有效</strong>。该标记会让命令程序忽略掉对已下载代码包的导入路径的检查。如果下载并安装的代码包所属的项目是你从别人那里 Fork 过来的，那么这样做就尤为重要了</li><li><strong>-t</strong>：<strong>让命令程序同时下载并安装指定的代码包中的测试源码文件中依赖的代码包</strong></li><li><strong>-fix</strong>：让命令程序在下载代码包后<strong>先执行修正动作</strong>，而后再进行编译和安装</li><li><strong>-insecure</strong>：<strong>允许命令程序使用非安全的 scheme（如 HTTP ）去下载指定的代码包</strong>。如果你用的代码仓库（如公司内部的 Gitlab ）没有HTTPS 支持，可以添加此标记。请在确定安全的情况下使用它</li></ul><p>这里说明一下-fix参数中的修正动作。比如说我们需要下载并安装的代码包，是在很早以前写的，其中使用的语法可能是go 1.0版本之前，而我们当前使用的语法时go1.4，那这其中的一些语法，以及对一些程序实体的使用方式，可能是不兼容的。为了消除这种不兼容，并可以使这个比较久远的代码包，能够被正确的编译和安装，此时就可以使用-fix参数。它会使命令程序，自动的把这些已经废弃的，或者不一样的语法语句、程序实体使用方式，修正成我们当前这个go语言版本所使用的方法和方式</p><h3 id="go-get-命令执行过程"><a href="#go-get-命令执行过程" class="headerlink" title="go get 命令执行过程"></a>go get 命令执行过程</h3><p>我这里没有直接演示go get命令的每个参数的使用，大家完全可以自己按照上边其它几个命令的使用方式来自己试一下go get的各个参数的作用。下边通过通用的-x参数，来看一下go get命令的执行过程</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash 代码解读复制代码执行：go get go get -x github.com/go-errors/errors</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> .</span><br><span class="line">git <span class="built_in">clone</span> -- &lt;https://github.com/go-errors/errors&gt; /Users/shulv/studySpace/GolangProject/src/github.com/go-errors/errors</span><br><span class="line"><span class="built_in">cd</span> /Users/shulv/studySpace/GolangProject/src/github.com/go-errors/errors</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"><span class="built_in">cd</span> /Users/shulv/studySpace/GolangProject/src/github.com/go-errors/errors</span><br><span class="line">git show-ref</span><br><span class="line"><span class="built_in">cd</span> /Users/shulv/studySpace/GolangProject/src/github.com/go-errors/errors</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">WORK=/var/folders/v2/8n4xnrln7l34q18v_2dt6tdr0000gn/T/go-build1679859398</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$WORK</span>/b001/</span><br><span class="line"><span class="built_in">mkdir</span> -p /Users/shulv/studySpace/GolangProject/pkg/darwin_amd64/github.com/go-errors/</span><br><span class="line"><span class="built_in">cp</span> /Users/shulv/Library/Caches/go-build/93/939c1986bb74b69ed1998e02c45b4326ba454a566c2996e5997560f8f68db355-d /Users/shulv/studySpace/GolangProject/pkg/darwin_amd64/github.com/go-errors/errors.a</span><br><span class="line"><span class="built_in">rm</span> -r <span class="variable">$WORK</span>/b001/</span><br></pre></td></tr></table></figure><p>根据其执行过程可以看到，执行完 go get 命令以后，会调用 git clone 方法下载源码，并编译，最终会把库源码文件编译成归档文件安装到 pkg 对应的相关平台目录下</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a718f40c3b744c28a238ac3c43d84921~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><h6 id="图片来源：初探-Go-的编译命令执行过程-3"><a href="#图片来源：初探-Go-的编译命令执行过程-3" class="headerlink" title="图片来源：初探 Go 的编译命令执行过程"></a>图片来源：<a href="https://juejin.cn/post/6844903489986887687#heading-10">初探 Go 的编译命令执行过程</a></h6><h1 id="感谢以下优秀文章"><a href="#感谢以下优秀文章" class="headerlink" title="感谢以下优秀文章"></a>感谢以下优秀文章</h1><p><a href="https://juejin.cn/post/6844903825900322829">Go的执行原理以及Go的命令</a></p><p><a href="https://juejin.cn/post/6844903489986887687">初探 Go 的编译命令执行过程</a></p><p><a href="https://juejin.cn/post/6844904087171907598">golang 标准命令</a></p><p><a href="https://studygolang.com/articles/21091">golang 命令详解</a></p><p><a href="https://blog.csdn.net/zyz770834013/article/details/78656985">go run go build go install 命令解释</a></p><p><a href="https://www.imooc.com/video/7208">go命令基础</a></p><p><a href="https://zhuanlan.zhihu.com/p/62922404">GO笔记之详解GO的编译执行流程</a></p><p>作者：书旅<br>链接：<a href="https://juejin.cn/post/6992047185340661768">https://juejin.cn/post/6992047185340661768</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go get 包下载失败</title>
      <link href="/post/6999fca8.html"/>
      <url>/post/6999fca8.html</url>
      
        <content type="html"><![CDATA[<p>由于某些不可抗力的原因，国内使用 <code>go get</code> 命令安装包时会经常会出现 timeout 的问题。本文介绍几个常用的解决办法。</p><p><strong>注意：这是一篇针对go 1.11之前版本国内 <code>go get</code> 命令安装包不成功的解决办法，现在的你极有可能只需要配置下 GOPROXY 即可解决相应包下载失败的问题。</strong></p><h2 id="从github克隆"><a href="#从github克隆" class="headerlink" title="从github克隆"></a>从github克隆</h2><p>golang在github上建立了一个镜像库，如<code>https://github.com/golang/net</code>就对应是 <code>https://golang.org/x/net</code>的镜像库。 要下载<code>golang.org/x/net</code>包，可以在本地创建包的目录后使用 <code>git clone</code> 来拉取相应包的源代码文件，具体操作如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$GOPATH</span>/src/golang.org/x</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/golang.org/x</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/golang/net.git</span><br></pre></td></tr></table></figure><h2 id="使用gopm"><a href="#使用gopm" class="headerlink" title="使用gopm"></a>使用gopm</h2><p>使用gopm可以从golang.org的一些镜像网站上下载。</p><h3 id="安装gopm"><a href="#安装gopm" class="headerlink" title="安装gopm"></a>安装gopm</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/gpmgo/gopm</span><br></pre></td></tr></table></figure><h3 id="使用gopm安装第三方包"><a href="#使用gopm安装第三方包" class="headerlink" title="使用gopm安装第三方包"></a>使用gopm安装第三方包</h3><p>不加<code>-g</code>参数，会把依赖包下载<code>.vendor</code>目录下面； 加上<code>-g</code>参数，可以把依赖包下载到<code>GOPATH</code>目录中。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gopm get -g golang.org/x/net  </span><br></pre></td></tr></table></figure><h2 id="使用goproxy"><a href="#使用goproxy" class="headerlink" title="使用goproxy"></a>使用goproxy</h2><p>Go的1.11版本以后 可以设置 <code>GOPROXY</code> 这个变量，来设置代理。 如果你自己有代理服务器就可以把这个环境变量设置成自己的代理。 首先开启 <code>go module</code> 支持:</p><p>在 Mac&#x2F;linux 下执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> GO111MODULE=on</span><br><span class="line">$ <span class="built_in">export</span> GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;export GO111MODULE=on&quot;</span> &gt;&gt; ~/.profile</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;export GOPROXY=https://goproxy.cn&quot;</span> &gt;&gt; ~/.profile</span><br><span class="line">$ <span class="built_in">source</span> ~/.profile</span><br></pre></td></tr></table></figure><p>Windows平台执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SET GO111MODULE=on</span><br><span class="line">SET GOPROXY=<span class="string">&quot;https://goproxy.cn&quot;</span></span><br></pre></td></tr></table></figure><p>或者在<code>PowerShell</code>中执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\&gt; <span class="variable">$env</span>:GO111MODULE = <span class="string">&quot;on&quot;</span></span><br><span class="line">C:\&gt; <span class="variable">$env</span>:GOPROXY = <span class="string">&quot;https://goproxy.cn&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Go-1-13-及以上（推荐）"><a href="#Go-1-13-及以上（推荐）" class="headerlink" title="Go 1.13 及以上（推荐）"></a>Go 1.13 及以上（推荐）</h3><p>打开你的终端并执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">env</span> -w GO111MODULE=on</span><br><span class="line">$ go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 环境变量</title>
      <link href="/post/2ddd6919.html"/>
      <url>/post/2ddd6919.html</url>
      
        <content type="html"><![CDATA[<p>Go 开发环境依赖于一些操作系统环境变量，你最好在安装 Go 之前就已经设置好他们。如果你使用的是 Windows 的话，你完全不用进行手动设置，Go 将被默认安装在目录 <code>c:/go</code> 下。这里列举几个最为重要的环境变量：</p><ul><li>$GOROOT 表示 Go 在你的电脑上的安装位置，它的值一般都是 <code>$HOME/go</code>，当然，你也可以安装在别的地方。</li><li>$GOARCH 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。</li><li>$GOOS 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。</li><li>$GOBIN 表示编译器和链接器的安装位置，默认是 <code>$GOROOT/bin</code>，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。<br>目标机器是指你打算运行你的 Go 应用程序的机器。</li></ul><p>Go 编译器支持交叉编译，也就是说你可以在一台机器上构建运行在具有不同操作系统和处理器架构上运行的应用程序，也就是说编写源代码的机器可以和目标机器有完全不同的特性（操作系统与处理器架构）。</p><p>为了区分本地机器和目标机器，你可以使用 <code>$GOHOSTOS</code> 和 <code>$GOHOSTARCH</code> 设置本地机器的操作系统名称和编译体系结构，这两个变量只有在进行交叉编译的时候才会用到，如果你不进行显式设置，他们的值会和目标机器（<code>$GOOS</code> 和 <code>$GOARCH</code>）一样。</p><ul><li>$GOPATH 默认采用和 $GOROOT 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个包含 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。</li><li>$GOARM 专门针对基于 arm 架构的处理器，它的值可以是 5~7，默认为 6。</li></ul><blockquote><p>GOARM&#x3D;5: 使用软件浮点（software floating point）；当 CPU 没有 VFP 协同处理器时</p><p>GOARM&#x3D;6: 仅使用 VFPv1; 使用交叉编译时的默认使用此选项，通常在 ARM11 或更高版本的内核中使用（也支持 VFPv2 或更高版本）</p><p>GOARM&#x3D;7: 使用 VFPv3；通常在 Cortex-A 内核中使用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin 快速入门</title>
      <link href="/post/6b9fbde2.html"/>
      <url>/post/6b9fbde2.html</url>
      
        <content type="html"><![CDATA[<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul><li>Go 1.16 及以上版本</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>要安装 Gin 软件包，需要先安装 Go 并设置 Go 工作区。</p><ol><li>下载并安装 gin：</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><blockquote><p>go get 加 -u 和不加 -u 参数的区别：加上它可以利用网络来更新已有的代码包及其依赖包。如果已经下载过一个代码包，但是这个代码包又有更新了，那么这时候可以直接用 -u 标记来更新本地的对应的代码包。如果不加这个 -u 标记，执行 go get 一个已有的代码包，会发现命令什么都不执行。只有加了 -u 标记，命令会去执行 git pull 命令拉取最新的代码包的最新版本，下载并安装。</p><p>不加<code>-g</code>参数，会把依赖包下载<code>.vendor</code>目录下面； 加上<code>-g</code>参数，可以把依赖包下载到<code>GOPATH</code>目录中。</p></blockquote><ol start="2"><li>将 gin 引入到代码中：</li></ol><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>（可选）如果使用诸如 http.StatusOK 之类的常量，则需要引入 net&#x2F;http 包：</li></ol><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>创建你的项目文件夹并 cd 进去</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p <span class="variable">$GOPATH</span>/src/github.com/myusername/project &amp;&amp; <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$_</span>&quot;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>拷贝一个初始模板到你的项目里</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl https://raw.githubusercontent.com/gin-gonic/examples/master/basic/main.go &gt; main.go</span><br></pre></td></tr></table></figure><ol start="6"><li>运行你的项目</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run main.go</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gin </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
